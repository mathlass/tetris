<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Tetris ‚Äì Vanilla JS (Einzeldatei) + Scoreboard</title>
  <!-- iOS/PWA -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="theme-color" content="#0f1115" />
  <link rel="manifest" href="manifest.json" />
  <link rel="apple-touch-icon" href="icons/icon-180.png" />
  <style>
    :root { --bg:#0f1115; --fg:#e8eaed; --muted:#a7b0be; --accent:#6ee7ff; }
    .theme-light { --bg:#ffffff; --fg:#202124; --muted:#5f6368; --accent:#0066cc; }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:500 16px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;overflow:hidden}
    .wrap{max-width:980px;margin:24px auto;padding:0 16px;display:grid;grid-template-columns:1fr auto;gap:24px}
    h1{font-size:28px;margin:0 0 8px}
    p{color:var(--muted);margin:0 0 12px}
    .grid{display:grid;grid-template-columns:320px 160px;gap:16px;align-items:start}
    @media (max-width:720px){
      .wrap{grid-template-columns:1fr}
      .grid{grid-template-columns:1fr}
      .mobile-controls{display:grid}
    }
    .panel{background:#161a23;border:1px solid #242a36;border-radius:16px;padding:14px 16px;box-shadow:0 10px 30px rgba(0,0,0,.2)}
    canvas{display:block;background:#0a0c10;border-radius:12px;border:1px solid #202533}
    .stats{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .stat{background:#0d1119;border:1px solid #1f2533;border-radius:12px;padding:10px;text-align:center}
    .stat b{display:block;font-size:22px;margin-top:6px;color:var(--accent)}
    .buttons{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
    button{cursor:pointer;border:1px solid #2a3142;background:#121722;color:var(--fg);padding:10px 14px;border-radius:12px}
    button:hover{background:#1a2030}
    kbd{background:#222739;border:1px solid #2c3550;border-bottom-width:3px;border-radius:6px;padding:2px 6px;margin:0 2px}
    ul{padding-left:18px;margin:6px 0}
    .next-hold{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
    .mini{background:#0d1119;border:1px solid #1f2533;border-radius:12px;padding:6px}
    .footer{grid-column:1/-1;color:#98a3b6;margin-top:8px}
    .tag{font-size:12px;color:#8aa4b8}
    .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:10px 0}
    .input{background:#0d1119;border:1px solid #1f2533;border-radius:10px;padding:8px 10px;color:var(--fg)}
    .table{width:100%;border-collapse:collapse;margin-top:8px}
    .table th,.table td{border:1px solid #1f2533;padding:8px;text-align:left}
    .table thead th{background:#0d1119;color:#8aa4b8}
    .table tbody tr:nth-child(even){background:#0f1521}
    /* Menu Overlay */
    #menuOverlay{position:fixed;inset:0;overflow-y:auto;background:rgba(0,0,0,.6);padding:24px 16px;opacity:0;pointer-events:none;transition:opacity .25s ease;z-index:9998}
    #menuOverlay.show{opacity:1;pointer-events:auto}
    /* Overlay Game Over */
    #overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;opacity:0;pointer-events:none;transition:opacity .25s ease;background:rgba(0,0,0,.45);backdrop-filter:blur(2px) saturate(1.1);z-index:9999}
    #overlay.show{opacity:1;pointer-events:auto}
    #overlay .overlay-card{background:#0d1119;border:1px solid #1f2533;border-radius:16px;padding:20px 22px;min-width:320px;max-width:90vw;animation:pop .3s ease-out}
    #overlay h2{margin:0 0 6px}
    @keyframes pop{from{transform:scale(.95);opacity:.6} to{transform:scale(1);opacity:1}}
    /* Pause Overlay */
    .board-wrap{position:relative;touch-action:none}
    #pauseOverlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-weight:800;font-size:48px;letter-spacing:2px;color:#e8eaed;background:rgba(0,0,0,.35);opacity:0;pointer-events:none;transition:opacity .2s ease;border-radius:12px}
    #pauseOverlay.show{opacity:1}
    /* Mobile touch controls */
    .mobile-controls{display:none;grid-template-columns:repeat(4,1fr);gap:8px;margin-top:10px}
    .mobile-controls button{padding:12px 10px;font-size:16px;border-radius:12px}
    .timer{font-weight:700; font-size:18px; color:var(--accent)}
  </style>
</head>
<body>
  <div class="wrap">
    <div>
      <h1>üß± Tetris</h1>
      <p class="tag">Vanilla¬†JavaScript ‚Ä¢ Canvas ‚Ä¢ Level/Score/Lines ‚Ä¢ Soft/Hard¬†Drop ‚Ä¢ Pause ‚Ä¢ Hold ‚Ä¢ 7‚ÄëBag¬†RNG</p>
      <button id="btnMenu" style="margin-bottom:8px">Men√º</button>
      <button id="themeToggle" style="margin-bottom:8px">Theme</button>
      <div class="grid">
        <div class="panel">
          <div class="stats" style="margin-bottom:8px">
            <div class="stat">Score<b id="score">0</b></div>
            <div class="stat">Level<b id="level">1</b></div>
            <div class="stat">Lines<b id="lines">0</b></div>
            <div class="stat">Best<b id="best">0</b></div>
          </div>
          <div class="controls" style="margin:0 0 8px">
            <label>Modus:
              <select id="modeSelect">
                <option value="classic">Classic (endlos)</option>
                <option value="ultra">Ultra ‚Äì 2 Minuten</option>
              </select>
            </label>
            <span class="timer" id="timer" style="margin-left:auto"></span>
          </div>
          <div class="board-wrap">
            <canvas id="game" width="300" height="600" aria-label="Tetris Board"></canvas>
            <div id="pauseOverlay" aria-hidden="true">PAUSE</div>
          </div>
          <div class="buttons">
            <button id="btnStart">Start/Neu</button>
            <button id="btnPause">Pause</button>
            <button id="btnHard">Hard¬†Drop (Leertaste)</button>
          </div>
          <div class="tag" id="comboTag"></div>
        </div>
          <div class="mobile-controls" aria-label="Touch Controls">
            <button id="mLeft">‚óÄÔ∏é</button>
            <button id="mRotate">‚ü≥</button>
            <button id="mRight">‚ñ∂Ô∏é</button>
            <button id="mHold">HOLD</button>
            <button id="mSoft">Soft ‚Üì</button>
            <button id="mHard">HARD ‚§ì</button>
            <button id="mPause">Pause</button>
            <button id="mStart">Neu</button>
          </div>
        </div>
        <div class="panel"><div class="next-hold">
            <div>
              <div class="tag">N√§chstes</div>
              <canvas id="next" class="mini" width="120" height="120"></canvas>
            </div>
            <div>
              <div class="tag">Hold (<kbd>Shift</kbd>)</div>
              <canvas id="hold" class="mini" width="120" height="120"></canvas>
            </div>
          </div>
          <h3>Steuerung</h3>
          <ul>
            <li><kbd>‚Üê</kbd>/<kbd>‚Üí</kbd>: bewegen</li>
            <li><kbd>‚Üì</kbd>: schneller fallen (Soft¬†Drop)</li>
            <li><kbd>‚Üë</kbd> oder <kbd>W</kbd>: rotieren (im Uhrzeigersinn)</li>
            <li><kbd>Leertaste</kbd>: Hard¬†Drop</li>
            <li><kbd>Shift</kbd>: Hold tauschen</li>
            <li><kbd>P</kbd>: Pause</li>
          </ul>
        </div>
      </div>

    </div>

  <div class="panel">
      <h3>Hinweise</h3>
      <ul>
        <li>Level steigt alle 10 Lines ‚Üí schnellere Fallgeschwindigkeit.</li>
        <li>Punkte: Single¬†=¬†100, Double¬†=¬†300, Triple¬†=¬†500, Tetris¬†=¬†800, Soft‚ÄëDrop¬†+1/Zelle, Hard‚ÄëDrop¬†+2/Zelle.</li>
        <li>Rotation: vereinfachtes SRS; Wandkicks an W√§nden und Stacks.</li>
      </ul>
    </div>

    <div class="footer">¬© 2025 ‚Äì Einzeldatei. Speichere diese Seite als <code>tetris.html</code> und √∂ffne sie im Browser.</div>
  </div>

  <div id="menuOverlay" aria-hidden="true">
    <button id="btnMenuClose" style="position:absolute;top:16px;right:16px">Schlie√üen</button>
    <div class="buttons" style="justify-content:center;margin:24px 0;">
      <button id="tabScore">Scoreboard</button>
      <button id="tabSettings">Einstellungen</button>
    </div>
    <div class="panel" id="scorePanel" style="margin-top:16px;">
      <h3>Scoreboard</h3>
      <div class="controls">
        <label for="playerName">Name:</label>
        <input id="playerName" class="input" placeholder="Dein Name" maxlength="16" />
        <button id="btnResetHS">Highscores l√∂schen</button>
      </div>
      <table class="table" id="hsTable">
        <thead>
          <tr><th>#</th><th>Name</th><th>Score</th><th>Lines</th><th>Level</th><th>Datum</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div class="panel" id="settingsPanel" style="margin-top:16px;display:none;">
      <h3>Einstellungen</h3>
      <div class="controls">
        <label><input type="checkbox" id="optSound" checked> Sound</label>
        <label><input type="checkbox" id="optGhost" checked> Ghost Piece</label>
        <label><input type="checkbox" id="optSoftDropPoints" checked> Soft‚ÄëDrop Punkte</label>
        <label>Farben:
          <select id="optPalette">
            <option value="standard">Standard</option>
            <option value="accessible">Barrierefrei</option>
          </select>
        </label>
      </div>
    </div>
  </div>

  <!-- Game Over Overlay -->
  <div id="overlay" aria-hidden="true">
    <div class="overlay-card" role="dialog" aria-modal="true" aria-labelledby="ovTitle">
      <h2 id="ovTitle">Game Over</h2>
      <p class="tag">Gut gespielt ‚Äì weiter geht's?</p>
      <div class="stats" style="margin-top:8px">
        <div class="stat">Score<b id="ovScore">0</b></div>
        <div class="stat">Lines<b id="ovLines">0</b></div>
        <div class="stat">Level<b id="ovLevel">0</b></div>
        <div class="stat">Best<b id="ovBest">0</b></div>
      </div>
      <div class="buttons" style="justify-content:center;margin-top:14px">
        <button id="btnRestart">Neu starten</button>
        <button id="btnClose">Schlie√üen</button>
      </div>
    </div>
  </div>

<script>
const THEME_KEY = 'tetris_theme';
if (localStorage.getItem(THEME_KEY) === 'light') {
  document.body.classList.add('theme-light');
}
const btnTheme = document.getElementById('themeToggle');
if (btnTheme) {
  btnTheme.addEventListener('click', () => {
    document.body.classList.toggle('theme-light');
    localStorage.setItem(
      THEME_KEY,
      document.body.classList.contains('theme-light') ? 'light' : 'dark'
    );
  });
}
(() => {
  // ==== Konfiguration
  const COLS=10, ROWS=20, SIZE=30;
  const FALL_BASE_MS = 800; // Basisintervall (Level 1)
  const LINES_PER_LEVEL = 10;
  const SCORE_LINE = [0,100,300,500,800];
  const SETTINGS_KEY = 'tetris_settings_v1';
  const MODE_CLASSIC = 'classic';
  const MODE_ULTRA = 'ultra';
  const ULTRA_SECONDS = 120;

  const COLOR_SETS = {
    standard: {
      0: '#000000', // leer (wird nicht gemalt)
      I: '#4fd1ff', J: '#4c6ef5', L: '#f59f00', O: '#fcc419',
      S: '#51cf66', T: '#be4bdb', Z: '#ff6b6b'
    },
    accessible: {
      0: '#000000',
      I: '#0072b2', J: '#56b4e9', L: '#e69f00', O: '#f0e442',
      S: '#009e73', T: '#cc79a7', Z: '#d55e00'
    }
  };
  let COLORS = COLOR_SETS.standard;

  // Tetromino-Matrizen (4√ó4 Frames) ‚Äì im Uhrzeigersinn rotierend
  const SHAPES = {
    I: [
      [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
      [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]],
      [[0,0,0,0],[0,0,0,0],[1,1,1,1],[0,0,0,0]],
      [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]]
    ],
    J: [
      [[1,0,0],[1,1,1],[0,0,0]],
      [[0,1,1],[0,1,0],[0,1,0]],
      [[0,0,0],[1,1,1],[0,0,1]],
      [[0,1,0],[0,1,0],[1,1,0]]
    ],
    L: [
      [[0,0,1],[1,1,1],[0,0,0]],
      [[0,1,0],[0,1,0],[0,1,1]],
      [[0,0,0],[1,1,1],[1,0,0]],
      [[1,1,0],[0,1,0],[0,1,0]]
    ],
    O: [
      [[1,1],[1,1]],
      [[1,1],[1,1]],
      [[1,1],[1,1]],
      [[1,1],[1,1]]
    ],
    S: [
      [[0,1,1],[1,1,0],[0,0,0]],
      [[0,1,0],[0,1,1],[0,0,1]],
      [[0,0,0],[0,1,1],[1,1,0]],
      [[1,0,0],[1,1,0],[0,1,0]]
    ],
    T: [
      [[0,1,0],[1,1,1],[0,0,0]],
      [[0,1,0],[0,1,1],[0,1,0]],
      [[0,0,0],[1,1,1],[0,1,0]],
      [[0,1,0],[1,1,0],[0,1,0]]
    ],
    Z: [
      [[1,1,0],[0,1,1],[0,0,0]],
      [[0,0,1],[0,1,1],[0,1,0]],
      [[0,0,0],[1,1,0],[0,1,1]],
      [[0,1,0],[1,1,0],[1,0,0]]
    ]
  };

  // ==== Highscores (LocalStorage)
  const HS_KEY = 'tetris_highscores_v1';
  function loadHS(){ try{ return JSON.parse(localStorage.getItem(HS_KEY)) || []; }catch(e){ return []; } }
  function saveHS(list){ localStorage.setItem(HS_KEY, JSON.stringify(list)); }
  function addHS(entry){
    const list = loadHS();
    list.push(entry);
    list.sort((a,b)=>b.score - a.score || b.lines - a.lines || b.level - a.level);
    const top10 = list.slice(0,10);
    saveHS(top10);
    return top10;
  }
  function renderHS(){
    const tbody = document.querySelector('#hsTable tbody');
    if(!tbody) return;
    const list = loadHS();
    tbody.innerHTML = list.map((e,i)=>
      `<tr><td>${i+1}</td><td>${e.name}</td><td>${e.score}</td><td>${e.lines}</td><td>${e.level}</td><td>${e.date}</td></tr>`
    ).join('');
  }

  // ==== Settings (persist)
  const defaultSettings = { sound:true, ghost:true, softDropPoints:true, palette:'standard' };
  function loadSettings(){
    try{ return Object.assign({}, defaultSettings, JSON.parse(localStorage.getItem(SETTINGS_KEY)||'{}')); }catch{ return {...defaultSettings}; }
  }
  function saveSettings(s){ localStorage.setItem(SETTINGS_KEY, JSON.stringify(s)); }
  let settings = loadSettings();
  COLORS = COLOR_SETS[settings.palette] || COLOR_SETS.standard;

  // ==== Audio (WebAudio beeps)
  let actx = null;
  function ensureAudio(){ if(!settings.sound) return null; if(!actx){ try{ actx = new (window.AudioContext||window.webkitAudioContext)(); }catch{} } return actx; }
  function beep(freq=440, dur=0.06, type='sine', gain=0.05){
    const ac = ensureAudio(); if(!ac) return;
    const o = ac.createOscillator(); const g = ac.createGain();
    o.type = type; o.frequency.value=freq; g.gain.value=gain;
    o.connect(g); g.connect(ac.destination);
    const t = ac.currentTime; o.start(t); o.stop(t+dur);
  }
  const sfx = {
    move: ()=>beep(300,0.03,'square',0.025),
    rotate: ()=>beep(520,0.04,'sine',0.035),
    lock: ()=>beep(220,0.06,'triangle',0.05),
    clear: ()=>{ beep(700,0.05,'sine',0.05); setTimeout(()=>beep(920,0.05,'sine',0.05),40); },
    level: ()=>{ beep(500,0.08,'triangle',0.06); setTimeout(()=>beep(750,0.08,'triangle',0.06),70); },
    hard: ()=>beep(180,0.05,'square',0.06),
    gameover: ()=>{ beep(200,0.08,'sawtooth',0.07); setTimeout(()=>beep(150,0.12,'sawtooth',0.06),90); }
  };

  // ==== Overlay helpers
  const overlay = () => document.getElementById('overlay');
  function showOverlay(vals){
    document.getElementById('ovScore').textContent = vals.score;
    document.getElementById('ovLines').textContent = vals.lines;
    document.getElementById('ovLevel').textContent = vals.level;
    document.getElementById('ovBest').textContent = vals.best;
    overlay().classList.add('show');
  }
  function hideOverlay(){ overlay().classList.remove('show'); }

  // ==== State
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const nextCanvas = document.getElementById('next');
  const nctx = nextCanvas.getContext('2d');
  const holdCanvas = document.getElementById('hold');
  const hctx = holdCanvas.getContext('2d');

  let board, cur, bag=[], queue=[], hold=null, canHold=true;
  let score=0, lines=0, level=1, best=Number(localStorage.getItem('tetris_best')||0);
  let combo=-1, backToBack=false;
  let mode = MODE_CLASSIC;
  let timeLeft = null; // in Sekunden f√ºr Ultra
  let dropTimer=0, dropInterval=FALL_BASE_MS, lastTime=0, paused=false, running=false;

  function setPaused(val){
    paused = val;
    const el = document.getElementById('pauseOverlay');
    if(el){
      el.classList.toggle('show', paused);
      el.setAttribute('aria-hidden', String(!paused));
    }
  }

  function emptyBoard(){
    return Array.from({length:ROWS}, ()=>Array(COLS).fill(0));
  }

  function newPiece(type){
    const shape = SHAPES[type];
    return {type, rot:0, x: Math.floor(COLS/2)-2, y: -2, shape};
  }

  function refillBag(){
    const types=['I','J','L','O','S','T','Z'];
    const shuffled = [...types].sort(()=>Math.random()-0.5);
    bag.push(...shuffled);
  }

  function pullNext(){
    if(bag.length<3) refillBag();
    const t = bag.shift();
    return newPiece(t);
  }

  function reset(){
    hideOverlay();
    board = emptyBoard();
    score=0; lines=0; level=1; dropInterval = FALL_BASE_MS; lastTime=0; dropTimer=0;
    bag=[]; queue = [pullNext(), pullNext(), pullNext()];
    cur = pullNext();
    hold=null; canHold=true; running=true; setPaused(false);
    // Mode & Timer
    const sel = document.getElementById('modeSelect');
    mode = sel ? sel.value : MODE_CLASSIC;
    timeLeft = (mode===MODE_ULTRA) ? ULTRA_SECONDS : null;
    updateSide(); drawBoard();
  }

  // ==== Rendering
  function drawCell(gx, gy, color, targetCtx=ctx, cellSize=SIZE){
    if(color===0) return;
    targetCtx.fillStyle = color;
    targetCtx.fillRect(gx*cellSize, gy*cellSize, cellSize, cellSize);
    // simple bevel
    targetCtx.fillStyle = 'rgba(255,255,255,0.12)';
    targetCtx.fillRect(gx*cellSize, gy*cellSize, cellSize, 4);
    targetCtx.fillStyle = 'rgba(0,0,0,0.25)';
    targetCtx.fillRect(gx*cellSize, gy*cellSize+cellSize-4, cellSize, 4);
  }

  function clearCanvas(c){ c.clearRect(0,0,c.canvas.width,c.canvas.height); }

  function drawBoard(){
    clearCanvas(ctx);
    // ghost piece (optional)
    if(settings.ghost){
      const ghostY = getDropY();
      drawPiece(cur, ghostY, true);
    }
    // board
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const v = board[y][x];
        if(v) drawCell(x,y,COLORS[v]);
      }
    }
    // current
    drawPiece(cur);
  }

  function drawPiece(p, overrideY=null, ghost=false){
    const m = p.shape[p.rot];
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if(m[y][x]){
          const cx = p.x + x;
          const cy = (overrideY??p.y) + y;
          if(cy<0) continue; // skip above board
          const color = ghost ? 'rgba(255,255,255,0.12)' : COLORS[p.type];
          drawCell(cx, cy, color);
        }
      }
    }
  }

  function drawMini(ctx2, piece){
    clearCanvas(ctx2);
    if(!piece) return;
    const m = piece.shape[0];
    const size = 24;
    const offX = Math.floor((ctx2.canvas.width/size - m[0].length)/2);
    const offY = Math.floor((ctx2.canvas.height/size - m.length)/2);
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if(m[y][x]) drawCell(offX+x, offY+y, COLORS[piece.type], ctx2, size);
      }
    }
  }

  function updateSide(){
    document.getElementById('score').textContent = score;
    document.getElementById('lines').textContent = lines;
    document.getElementById('level').textContent = level;
    document.getElementById('best').textContent = best;
    drawMini(nctx, queue[0]);
    drawMini(hctx, hold);
    const comboEl = document.getElementById('comboTag');
    if(comboEl){
      let t = '';
      if(combo>=1) t += `Combo x${combo+1}`;
      if(backToBack) t += (t?' ‚Ä¢ ':'')+`Back‚Äëto‚ÄëBack`;
      comboEl.textContent = t;
    }
  }

  // ==== Logik
  function collides(p){
    const m = p.shape[p.rot];
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if(!m[y][x]) continue;
        const nx = p.x + x;
        const ny = p.y + y;
        if(nx<0 || nx>=COLS || ny>=ROWS) return true;
        if(ny>=0 && board[ny][nx]) return true;
      }
    }
    return false;
  }

  function isOutOfTop(p){
    const m = p.shape[p.rot];
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if(m[y][x] && (p.y + y) < 0) return true;
      }
    }
    return false;
  }

  function rotate(p){
    const test = {...p, rot:(p.rot+1)%p.shape.length};
    if(!collides(test)) return test;
    for(const dx of [-1,1,-2,2]){
      const kicked = {...test, x:test.x+dx};
      if(!collides(kicked)) return kicked;
    }
    return p;
  }

  function merge(){
    const m = cur.shape[cur.rot];
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if(!m[y][x]) continue;
        const by = cur.y+y;
        if(by<0) continue;
        board[by][cur.x+x] = cur.type;
      }
    }
  }

  function clearLines(){
    let cleared=0;
    outer: for(let y=ROWS-1;y>=0;y--){
      for(let x=0;x<COLS;x++){
        if(!board[y][x]) continue outer;
      }
      board.splice(y,1);
      board.unshift(Array(COLS).fill(0));
      cleared++;
      y++;
    }
    if(cleared>0){
      score += SCORE_LINE[cleared];
      combo = (combo<0?0:combo+1);
      score += Math.max(0, combo) * 50;
      if(cleared===4){ if(backToBack) score += 200; backToBack=true; } else backToBack=false;
      lines += cleared;
      const newLevel = Math.floor(lines / LINES_PER_LEVEL) + 1;
      if(newLevel>level){ level = newLevel; dropInterval = Math.max(80, FALL_BASE_MS * Math.pow(0.85, level-1)); sfx.level(); }
      sfx.clear();
    } else {
      combo = -1;
    }
  }

  function getDropY(){
    const p = {...cur};
    while(true){
      p.y++;
      if(collides(p)) { p.y--; return p.y; }
    }
  }

  function hardDrop(){
    const targetY = getDropY();
    const dropped = targetY - cur.y;
    cur.y = targetY;
    if(settings.softDropPoints) score += dropped*2;
    sfx.hard();
    lockPiece();
  }

  function softDrop(){
    const p = {...cur, y:cur.y+1};
    if(!collides(p)) { cur.y++; if(settings.softDropPoints) score += 1; }
    else lockPiece();
  }

  function lockPiece(){
    if(isOutOfTop(cur)) { gameOver(); return; }
    sfx.lock();
    merge();
    clearLines();
    cur = queue.shift();
    queue.push(pullNext());
    canHold=true;
    if(collides(cur)) { gameOver(); return; }
    updateSide();
  }

  function gameOver(){
    running=false;
    setPaused(false);
    best = Math.max(best, score);
    localStorage.setItem('tetris_best', best);
    const nameEl = document.getElementById('playerName');
    const name = (nameEl && nameEl.value ? nameEl.value : 'Player').trim() || 'Player';
    addHS({ name, score, lines, level, date: new Date().toISOString().slice(0,10) });
    renderHS();
    updateSide();
    showOverlay({score, lines, level, best});
    sfx.gameover();
  }

  // ==== Loop
  function update(time=0){
    if(!running) return;
    const delta = time - lastTime; lastTime = time;
    if(!paused){
      // Timer-Logik f√ºr Ultra Mode
      if(timeLeft!==null){
        timeLeft = Math.max(0, timeLeft - delta/1000);
        const tEl = document.getElementById('timer');
        if(tEl){ const s=Math.floor(timeLeft%60).toString().padStart(2,'0'); tEl.textContent=`‚è±Ô∏è ${Math.floor(timeLeft/60)}:${s}`; }
        if(timeLeft===0){ gameOver(); }
      }
      dropTimer += delta;
      if(dropTimer > dropInterval){
        softDrop();
        dropTimer = 0;
      }
      drawBoard();
    }
    requestAnimationFrame(update);
  }

  // ==== Input
  window.addEventListener('keydown', (e)=>{
    // Overlay hat Vorrang: Enter = Neustart, Escape = Schlie√üen
    const ov = document.getElementById('overlay');
    if(ov && ov.classList.contains('show')){
      if(['Enter','NumpadEnter'].includes(e.code)) { e.preventDefault(); reset(); update(); return; }
      if(e.code==='Escape') { e.preventDefault(); hideOverlay(); return; }
      e.preventDefault(); return;
    }

    const mOverlay = document.getElementById('menuOverlay');
    if(mOverlay && mOverlay.classList.contains('show')){
      if(e.code==='Escape'){ e.preventDefault(); toggleMenu(); }
      return;
    }

    if(!running) return;
    if(e.code==='KeyP'){ setPaused(!paused); return; }
    if(paused) return;
    if(['ArrowLeft','ArrowRight','ArrowDown','ArrowUp','Space','KeyW','ShiftLeft','ShiftRight'].includes(e.code)) e.preventDefault();
    switch(e.code){
      case 'ArrowLeft':{
        const p = {...cur, x:cur.x-1};
        if(!collides(p)) { cur.x--; sfx.move(); }
        break;
      }
      case 'ArrowRight':{
        const p = {...cur, x:cur.x+1};
        if(!collides(p)) { cur.x++; sfx.move(); }
        break;
      }
      case 'ArrowDown': softDrop(); break;
      case 'ArrowUp':
      case 'KeyW': cur = rotate(cur); sfx.rotate(); break;
      case 'Space': hardDrop(); break;
      case 'ShiftLeft':
      case 'ShiftRight': {
        if(!canHold) break;
        const tmp = hold ? newPiece(hold.type) : null;
        hold = newPiece(cur.type);
        if(tmp){ cur = tmp; cur.x = Math.floor(COLS/2)-2; cur.y=-2; }
        else { cur = queue.shift(); queue.push(pullNext()); }
        canHold=false; updateSide();
        break;
      }
    }
  }, {passive:false});

  // ==== UI Buttons
  const menuOverlay = document.getElementById('menuOverlay');
  let menuPrevPaused = false;
  function toggleMenu(){
    const show = !menuOverlay.classList.contains('show');
    menuOverlay.classList.toggle('show', show);
    menuOverlay.setAttribute('aria-hidden', String(!show));
    if(show){
      menuPrevPaused = paused;
      setPaused(true);
    } else {
      setPaused(menuPrevPaused);
    }
  }
  const btnMenu = document.getElementById('btnMenu');
  if(btnMenu){ btnMenu.addEventListener('click', toggleMenu); }
  const btnMenuClose = document.getElementById('btnMenuClose');
  if(btnMenuClose){ btnMenuClose.addEventListener('click', toggleMenu); }
  const tabScore = document.getElementById('tabScore');
  const tabSettings = document.getElementById('tabSettings');
  const scorePanel = document.getElementById('scorePanel');
  const settingsPanel = document.getElementById('settingsPanel');
  if(tabScore && tabSettings){
    tabScore.addEventListener('click', ()=>{ scorePanel.style.display='block'; settingsPanel.style.display='none'; });
    tabSettings.addEventListener('click', ()=>{ scorePanel.style.display='none'; settingsPanel.style.display='block'; });
  }
  document.getElementById('btnStart').addEventListener('click', ()=>{ reset(); update(); });
  const modeSelect = document.getElementById('modeSelect');
  if(modeSelect){ modeSelect.addEventListener('change', ()=>{ reset(); update(); }); }
  document.getElementById('btnPause').addEventListener('click', ()=>{ if(running){ setPaused(!paused); }});
  document.getElementById('btnHard').addEventListener('click', ()=>{ if(running&&!paused) hardDrop(); });
  const btnResetHS = document.getElementById('btnResetHS');
  if(btnResetHS){
    btnResetHS.addEventListener('click', ()=>{
      saveHS([]);
      best = 0;
      localStorage.removeItem('tetris_best');
      updateSide();
      renderHS();
    });
  }
  // Overlay Buttons
  const btnRestart = document.getElementById('btnRestart');
  if(btnRestart){ btnRestart.addEventListener('click', ()=>{ reset(); update(); }); }
  const btnClose = document.getElementById('btnClose');
  if(btnClose){ btnClose.addEventListener('click', ()=> hideOverlay()); }

  // Touch Buttons
  const touchMap = {
    mLeft:()=>{const p={...cur,x:cur.x-1}; if(!collides(p)) {cur.x--; sfx.move();}},
    mRight:()=>{const p={...cur,x:cur.x+1}; if(!collides(p)) {cur.x++; sfx.move();}},
    mRotate:()=>{cur=rotate(cur); sfx.rotate();},
    mSoft:()=>softDrop(),
    mHard:()=>hardDrop(),
    mHold:()=>{ if(!canHold) return; const tmp = hold ? newPiece(hold.type) : null; hold = newPiece(cur.type); if(tmp){ cur = tmp; cur.x=Math.floor(COLS/2)-2; cur.y=-2; } else { cur=queue.shift(); queue.push(pullNext()); } canHold=false; updateSide(); },
    mPause:()=>{ if(running){ setPaused(!paused); } },
    mStart:()=>{ reset(); update(); }
  };
  Object.keys(touchMap).forEach(id=>{ const el=document.getElementById(id); if(el){ el.addEventListener('click', touchMap[id]); }});

  // Swipe Gestures auf dem Board
  (function(){
    const el=document.querySelector('.board-wrap'); if(!el) return;
    let sx=0, sy=0, st=0;
    el.addEventListener('touchstart', (e)=>{ const t=e.changedTouches[0]; sx=t.clientX; sy=t.clientY; st=performance.now();});
    el.addEventListener('touchend', (e)=>{
      const t=e.changedTouches[0]; const dx=t.clientX-sx; const dy=t.clientY-sy; const dt=performance.now()-st;
      const absX=Math.abs(dx), absY=Math.abs(dy);
      const THRESH=24; // Pixel
      if(dt<400){
        if(absX>absY && absX>THRESH){ if(dx>0) touchMap.mRight(); else touchMap.mLeft(); return; }
        if(absY>absX && absY>THRESH){ if(dy>0) touchMap.mHard(); else touchMap.mRotate(); return; }
        if(absX<10 && absY<10) touchMap.mRotate();
      }
    }, {passive:true});
  })();

  // Settings bindings
  const chkSound = document.getElementById('optSound');
  const chkGhost = document.getElementById('optGhost');
  const chkSoft = document.getElementById('optSoftDropPoints');
  const selPalette = document.getElementById('optPalette');
  if(chkSound){ chkSound.checked = !!settings.sound; chkSound.addEventListener('change', ()=>{ settings.sound = chkSound.checked; saveSettings(settings); }); }
  if(chkGhost){ chkGhost.checked = !!settings.ghost; chkGhost.addEventListener('change', ()=>{ settings.ghost = chkGhost.checked; saveSettings(settings); drawBoard(); }); }
  if(chkSoft){ chkSoft.checked = !!settings.softDropPoints; chkSoft.addEventListener('change', ()=>{ settings.softDropPoints = chkSoft.checked; saveSettings(settings); }); }
  if(selPalette){
    selPalette.value = settings.palette || 'standard';
    selPalette.addEventListener('change', ()=>{
      settings.palette = selPalette.value;
      COLORS = COLOR_SETS[settings.palette] || COLOR_SETS.standard;
      saveSettings(settings);
      drawBoard();
      updateSide();
    });
  }

  // Initiale Anzeige
  renderHS();
  updateSide();
})();

// Register external Service Worker (works on Netlify & GitHub Pages)
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('sw.js', { scope: './' }).catch(()=>{});
  });
}
</script>
</body>
</html>
